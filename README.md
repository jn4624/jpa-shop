### 1. 기능 목록
- 회원 기능
  - 회원 등록
  - 회원 조회
- 상품 기능
  - 상품 등록
  - 상품 수정
  - 상품 조회
- 주문 기능
  - 상품 주문
  - 주문 내역 조회
  - 주문 취소
- 기타 요구사항
  - 상품은 재고 관리가 필요하다.
  - 상품의 종류는 도서, 음반, 영화가 있다.
  - 상품을 카테고리로 구분할 수 있다.
  - 상품 주문시 배송 정보를 입력할 수 있다.

### 2. 도메인 모델 분석
<img src="https://github.com/jn4624/jpa-shop-web/assets/60414800/198db36d-8fbf-44c6-89db-be2aab7c2614" width="600">

### 3. 엔티티 분석
<img src="https://github.com/jn4624/jpa-shop-web/assets/60414800/92ef8742-4573-4a22-b968-39c83a9422c8" width="600">

### 4. 테이블 분석
<img src="https://github.com/jn4624/jpa-shop-web/assets/60414800/85573ad7-934a-4f29-8e33-dfb21528a8d2" width="600">

### 5. 애플리케이션 아키텍처
<img src="https://github.com/jn4624/jpa-shop-web/assets/60414800/a2e65d68-6148-45d8-9ed6-75015ce82e2e" width="600">

- 계층형 구조 사용
  - controller, web: 웹 계층
  - service: 비즈니스 로직, 트랜잭션 처리
  - repository: JPA를 직접 사용하는 계층, 엔티티 매니저 사용
  - domain: 엔티티가 모여 있는 계층, 모든 계층에서 사용


- 패키지 구조
  - jpashop
    - domain
    - exception
    - repository
    - service
    - web


  개발 순서: 서비스, 레포지토리 계층 개발 -> 테스트 케이스 작성 및 검증 -> 웹 계층 적용

### 참고
- 엔티티가 비즈니스 로직을 가지고 객체 지향의 특성을 적극 활용하는 것: 도메인 모델 패턴
- 엔티티에는 비즈니스 로직이 거의 없고 서비스 계층에서 대부분의 비즈니스 로직을 처리하는 것: 트랜잭션 스크립트 패턴

### 6. 지연 로딩과 조회 성능 최적화
- 쿼리 방식 선택 권장 순서
  - 엔티티를 DTO 변환하여 반환
  - 필요시 fetch join 사용하여 성능 최적화 (재사용성 높음)
  - 그래도 안되면 DTO 직접 조회 방법 사용 (재사용성 낮음)
  - 최후의 방법은 JPA 제공 네이틔브 SQL 이나 JDBC Template 사용하여 SQL 직접 사용

### 7. 컬렉션 조회 최적화
- 권장 순서
  - 엔티티 조회 방식으로 우선 접근
    - fetch join으로 쿼리 수 최적화
    - 컬렉션 최적화
      - 페이징 필요o: hibernate.default_batch_fetch_size, @BatchSize로 최적화
      - 페이징 필요x: fetch join 사용
  - 엔티티 조회 방식으로 해결되지 않으면 DTO 조회 방식 사용
  - DTO 조회 방식으로 해결되지 않으면 NativeSQL or JdbcTemplate 사용

### 참고
- 엔티티 조회 방식은 fetch join이나 hibernate.default_batch_fetch_size, @BatchSize 사용으로
  코드를 거의 수정하지 않고, 옵션만 약간 변경하여 다양한 성능 최적화를 시도할 수 있다.
  반면 DTO 조회 방식은 성능을 최적화하거나, 성능 최적화 방식을 변경할 때 많은 코드 변경이 일어난다.
- 개발자는 성능 최적화와 코드 복잡도 사이에서 줄타기를 해야 한다.
  항상 그런 것은 아니지만, 보통 성능 최적화는 단순한 코드를 복잡한 코드로 몰고간다.
  엔티티 조회 방식은 JPA가 많은 부분을 최적화 해주기 때문에, 단순한 코드를 유지하면서 성능을 최적화할 수 있다.
  반면 DTO 조회 방식은 SQL을 직접 다루는 것과 유사하기 때문에 둘 사이에 줄타기를 해야 한다.

### DTO 조회 방식의 선택지
- DTO 조회 방식도 각 장단점이 있다.
  - V4, V5, V6에서 단순하게 쿼리가 1번 실행된다고 V6가 항상 좋은 방법인 것은 아니다.
- V4 방식
  - 코드가 단순하다.
  - 특정 주문 한 건만 조회하면 이 방식을 사용해도 성능이 잘 나온다.
  - 예를 들어 조회한 Order 데이터가 1건이면 OrderItem을 찾기 위한 쿼리도 1번만 실행 된다.
- V5 방식
  - 코드가 복잡하다.
  - 여러 주문을 한꺼번에 조회하는 경우에는 V4 대신 이것을 최적화 한 V5 방식을 사용해야 한다.
  - 예를 들어 조회한 Order 데이터가 1000건인데 V4 방식을 그대로 사용하면, 쿼리가 총 1 + 1000번 실행된다.
  - 반면 V5 방식을 사용하면 쿼리가 총 1 + 1번 실행된다.
  - 상황에 따라 다르겠지만 운영환경에서 100배 이상의 성능 차이가 날 수 있다.
- V6 방식
  - 완전히 다른 접근 방식이다.
  - 쿼리 한번으로 최적화 되어서 상당히 좋아보이지만, Order를 기준으로 페이징이 불가능하다.
  - 실무에서는 이 정도 데이터면 수백이나, 수천건 단위로 페이징 처리가 꼭 필요하므로, 이 경우 선택하기 어려운 방법이다.
  - 데이터가 많으면 중복 전송이 증가해 V5 방식과 비교해서 성능 차이도 미비하다.
